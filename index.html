<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Score Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/recharts@2.5.0/dist/Recharts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;
        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = Recharts;
        
        function WordleAnalyzer() {
            const [data, setData] = useState([]);
            const [players, setPlayers] = useState([]);
            const [stats, setStats] = useState(null);
            const [scoringMode, setScoringMode] = useState('penalty');
            const [penaltyData, setPenaltyData] = useState([]);

            const parseWhatsAppChat = (text) => {
                const lines = text.split('\n');
                const wordlePattern = /Wordle ([\d,]+) ([X1-6])\/6/i;
                const scores = [];
                const playerSet = new Set();

                lines.forEach(line => {
                    const messageMatch = line.match(/\[(.*?)\] (.*?): (.*)/);
                    if (!messageMatch) return;
                    const [, , name, message] = messageMatch;
                    const wordleMatch = message.match(wordlePattern);
                    if (wordleMatch) {
                        const wordleNum = parseInt(wordleMatch[1].replace(/,/g, ''));
                        const score = wordleMatch[2] === 'X' ? 7 : parseInt(wordleMatch[2]);
                        scores.push({ wordleNumber: wordleNum, player: name.trim(), score: score });
                        playerSet.add(name.trim());
                    }
                });
                return { scores, players: Array.from(playerSet) };
            };

            const applyPenalties = (scores, playerList) => {
                const allWordleNumbers = [...new Set(scores.map(s => s.wordleNumber))].sort((a, b) => a - b);
                const penalizedScores = [...scores];
                
                allWordleNumbers.forEach(wordleNum => {
                    const scoresForDay = scores.filter(s => s.wordleNumber === wordleNum);
                    const playersWhoPosted = scoresForDay.map(s => s.player);
                    const playersWhoMissed = playerList.filter(p => !playersWhoPosted.includes(p));
                    
                    if (playersWhoMissed.length > 0 && scoresForDay.length > 0) {
                        const worstScore = Math.max(...scoresForDay.map(s => s.score));
                        const penaltyScore = worstScore + 1;
                        
                        playersWhoMissed.forEach(player => {
                            penalizedScores.push({
                                wordleNumber: wordleNum,
                                player: player,
                                score: penaltyScore,
                                isPenalty: true
                            });
                        });
                    }
                });
                return penalizedScores;
            };

            const calculateStats = (scores, playerList) => {
                const playerStats = {};
                
                playerList.forEach(player => {
                    const playerScores = scores.filter(s => s.player === player);
                    const validScores = playerScores.filter(s => s.score <= 6);
                    const sortedScores = [...playerScores].sort((a, b) => a.wordleNumber - b.wordleNumber);
                    
                    let maxStreak = 0, tempStreak = 0, expectedNum = null;
                    
                    for (let i = 0; i < sortedScores.length; i++) {
                        const isSuccess = sortedScores[i].score <= 6;
                        const isConsecutive = expectedNum === null || sortedScores[i].wordleNumber === expectedNum;
                        
                        if (isSuccess && isConsecutive) {
                            tempStreak++;
                            maxStreak = Math.max(maxStreak, tempStreak);
                            expectedNum = sortedScores[i].wordleNumber + 1;
                        } else if (isSuccess) {
                            tempStreak = 1;
                            expectedNum = sortedScores[i].wordleNumber + 1;
                        } else {
                            tempStreak = 0;
                            expectedNum = sortedScores[i].wordleNumber + 1;
                        }
                    }
                    
                    let currentStreak = 0;
                    expectedNum = null;
                    for (let i = sortedScores.length - 1; i >= 0; i--) {
                        const isSuccess = sortedScores[i].score <= 6;
                        const isConsecutive = expectedNum === null || sortedScores[i].wordleNumber === expectedNum;
                        if (isSuccess && isConsecutive) {
                            currentStreak++;
                            expectedNum = sortedScores[i].wordleNumber - 1;
                        } else {
                            break;
                        }
                    }
                    
                    const recentWordleNum = Math.max(...playerScores.map(s => s.wordleNumber));
                    const weekScores = playerScores.filter(s => s.wordleNumber >= recentWordleNum - 7 && s.score <= 6);
                    const weekAvg = weekScores.length > 0 ? (weekScores.reduce((sum, s) => sum + s.score, 0) / weekScores.length).toFixed(2) : 'N/A';
                    
                    playerStats[player] = {
                        average: validScores.length > 0 ? (validScores.reduce((sum, s) => sum + s.score, 0) / validScores.length).toFixed(2) : 'N/A',
                        weekAverage: weekAvg,
                        currentStreak: currentStreak,
                        maxStreak: maxStreak
                    };
                });
                return playerStats;
            };

            const getRunsAndRuts = (player, useData) => {
                const playerScores = useData.filter(d => d.player === player).sort((a, b) => a.wordleNumber - b.wordleNumber);
                const validScores = playerScores.filter(s => s.score <= 6);
                const overallAvg = validScores.length > 0 ? validScores.reduce((sum, s) => sum + s.score, 0) / validScores.length : 4;
                
                const runsRuts = [];
                const windowSize = 10;
                
                for (let i = 0; i <= playerScores.length - windowSize; i++) {
                    const window = playerScores.slice(i, i + windowSize).filter(s => s.score <= 6);
                    if (window.length < windowSize) continue;
                    
                    const windowAvg = window.reduce((sum, s) => sum + s.score, 0) / window.length;
                    const diff = windowAvg - overallAvg;
                    
                    if (Math.abs(diff) > 0.4) {
                        const lastPeriod = runsRuts[runsRuts.length - 1];
                        const currentStart = playerScores[i].wordleNumber;
                        const currentEnd = playerScores[i + windowSize - 1].wordleNumber;
                        
                        if (lastPeriod && currentStart <= lastPeriod.end + 1 && 
                            ((diff < 0 && lastPeriod.type === 'run') || (diff > 0 && lastPeriod.type === 'rut'))) {
                            lastPeriod.end = currentEnd;
                            lastPeriod.avg = windowAvg.toFixed(2);
                            lastPeriod.length = lastPeriod.end - lastPeriod.start + 1;
                            lastPeriod.diff = diff.toFixed(2);
                        } else if (!lastPeriod || currentStart > lastPeriod.end + 1) {
                            runsRuts.push({
                                start: currentStart,
                                end: currentEnd,
                                length: windowSize,
                                avg: windowAvg.toFixed(2),
                                diff: diff.toFixed(2),
                                type: diff < 0 ? 'run' : 'rut'
                            });
                        }
                    }
                }
                return runsRuts.filter(p => p.length >= 15);
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const { scores, players: foundPlayers } = parseWhatsAppChat(text);
                    setData(scores);
                    setPlayers(foundPlayers);
                    const penalized = applyPenalties(scores, foundPlayers);
                    setPenaltyData(penalized);
                    setStats(calculateStats(scores, foundPlayers));
                };
                reader.readAsText(file);
            };

            const currentData = scoringMode === 'raw' ? data : penaltyData;
            const currentStats = scoringMode === 'raw' ? stats : (penaltyData.length > 0 ? calculateStats(penaltyData, players) : stats);

            const getRunningAvg = () => {
                if (currentData.length === 0) return [];
                const wordleNumbers = [...new Set(currentData.map(d => d.wordleNumber))].sort((a, b) => a - b);
                return wordleNumbers.map((num) => {
                    const entry = { wordleNumber: num };
                    players.forEach(player => {
                        const playerScores = currentData.filter(d => d.player === player && d.wordleNumber <= num);
                        const validScores = playerScores.filter(s => s.score <= 6);
                        if (validScores.length > 0) {
                            const avg = validScores.reduce((sum, s) => sum + s.score, 0) / validScores.length;
                            entry[player] = (avg >= 3.6 && avg <= 4.5) ? avg : null;
                        } else {
                            entry[player] = null;
                        }
                    });
                    return entry;
                });
            };

            const getRunningAvgZoomed = () => {
                if (currentData.length === 0) return [];
                const wordleNumbers = [...new Set(currentData.map(d => d.wordleNumber))].sort((a, b) => a - b);
                return wordleNumbers.filter(num => num >= 1000).map((num) => {
                    const entry = { wordleNumber: num };
                    players.forEach(player => {
                        const playerScores = currentData.filter(d => d.player === player && d.wordleNumber <= num);
                        const validScores = playerScores.filter(s => s.score <= 6);
                        if (validScores.length > 0) {
                            const avg = validScores.reduce((sum, s) => sum + s.score, 0) / validScores.length;
                            entry[player] = (avg >= 3.6 && avg <= 4.1) ? avg : null;
                        } else {
                            entry[player] = null;
                        }
                    });
                    return entry;
                });
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 p-6">
                    <div className="max-w-7xl mx-auto">
                        <div className="bg-white rounded-lg shadow-lg p-8 mb-6">
                            <h1 className="text-3xl font-bold text-gray-800 mb-6">üéØ Wordle Score Analyzer</h1>

                            <label className="cursor-pointer block">
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-green-500 transition">
                                    <div className="text-6xl mb-2">üì§</div>
                                    <span className="text-sm font-semibold block">Upload WhatsApp Chat</span>
                                    <p className="text-xs text-gray-500 mt-1">Export chat from WhatsApp (.txt)</p>
                                    <input type="file" accept=".txt" onChange={handleFileUpload} className="hidden" />
                                </div>
                            </label>

                            {data.length > 0 && (
                                <>
                                    <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 my-4">
                                        <p className="text-sm font-semibold text-blue-900 mb-1">Scoring Rules:</p>
                                        <ul className="text-sm text-blue-800 space-y-1 ml-4">
                                            <li>‚Ä¢ Failed puzzle (X/6): 7 points</li>
                                            <li>‚Ä¢ Missing a day (Penalty Mode): Worst score + 1 point</li>
                                        </ul>
                                    </div>

                                    <div className="flex gap-2 mb-6 flex-wrap">
                                        <button 
                                            onClick={() => setScoringMode('penalty')} 
                                            className={`px-6 py-3 rounded-lg font-semibold ${scoringMode === 'penalty' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                        >
                                            Penalty Scores
                                        </button>
                                        <button 
                                            onClick={() => setScoringMode('raw')} 
                                            className={`px-6 py-3 rounded-lg font-semibold ${scoringMode === 'raw' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
                                        >
                                            Raw Scores
                                        </button>
                                    </div>

                                    <div className="bg-green-50 rounded-lg p-4">
                                        <p className="font-semibold">{currentData.length} scores from {players.length} players</p>
                                        <p className="text-sm">Players: {players.join(', ')}</p>
                                    </div>
                                </>
                            )}
                        </div>

                        {currentStats && (
                            <>
                                <div className="bg-gradient-to-r from-yellow-400 to-yellow-600 rounded-lg shadow-lg p-8 mb-6 text-center text-white">
                                    <h2 className="text-3xl font-bold mb-2">üèÜ Wordler of the Week üèÜ</h2>
                                    <p className="text-2xl font-semibold">
                                        {players.reduce((best, player) => {
                                            const playerAvg = parseFloat(currentStats[player].weekAverage);
                                            const bestAvg = parseFloat(currentStats[best].weekAverage);
                                            if (isNaN(playerAvg)) return best;
                                            if (isNaN(bestAvg)) return player;
                                            return playerAvg < bestAvg ? player : best;
                                        })}
                                    </p>
                                </div>

                                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                    <h2 className="text-2xl font-bold mb-4">Performance Summary</h2>
                                    <div className="overflow-x-auto">
                                        <table className="w-full">
                                            <thead>
                                                <tr className="border-b-2">
                                                    <th className="text-left py-3 px-4">Player</th>
                                                    <th className="text-center py-3 px-4">Week Avg</th>
                                                    <th className="text-center py-3 px-4">All-Time</th>
                                                    <th className="text-center py-3 px-4">Streak</th>
                                                    <th className="text-center py-3 px-4">Max</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {players.sort((a, b) => parseFloat(currentStats[a].average) - parseFloat(currentStats[b].average))
                                                    .map((player, idx) => (
                                                        <tr key={player} className={idx % 2 === 0 ? 'bg-gray-50' : ''}>
                                                            <td className="py-3 px-4 font-medium">{player}</td>
                                                            <td className="text-center py-3 px-4">{currentStats[player].weekAverage}</td>
                                                            <td className="text-center py-3 px-4 font-bold text-green-600">{currentStats[player].average}</td>
                                                            <td className="text-center py-3 px-4">{currentStats[player].currentStreak}</td>
                                                            <td className="text-center py-3 px-4">{currentStats[player].maxStreak}</td>
                                                        </tr>
                                                    ))}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>

                                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                    <h2 className="text-xl font-bold mb-4">Cumulative Average (3.6-4.5)</h2>
                                    <ResponsiveContainer width="100%" height={400}>
                                        <LineChart data={getRunningAvg()}>
                                            <CartesianGrid strokeDasharray="3 3" />
                                            <XAxis dataKey="wordleNumber" />
                                            <YAxis domain={[3.6, 4.5]} />
                                            <Tooltip />
                                            <Legend />
                                            {players.map((player, idx) => (
                                                <Line 
                                                    key={player} 
                                                    type="monotone" 
                                                    dataKey={player} 
                                                    stroke={`hsl(${idx * 360 / players.length}, 70%, 50%)`} 
                                                    strokeWidth={2} 
                                                    connectNulls 
                                                    dot={false}
                                                />
                                            ))}
                                        </LineChart>
                                    </ResponsiveContainer>
                                </div>

                                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                    <h2 className="text-xl font-bold mb-4">Wordle 1000+ - Cumulative Average (3.6-4.1)</h2>
                                    <ResponsiveContainer width="100%" height={400}>
                                        <LineChart data={getRunningAvgZoomed()}>
                                            <CartesianGrid strokeDasharray="3 3" />
                                            <XAxis dataKey="wordleNumber" />
                                            <YAxis domain={[3.6, 4.1]} />
                                            <Tooltip />
                                            <Legend />
                                            {players.map((player, idx) => (
                                                <Line 
                                                    key={player} 
                                                    type="monotone" 
                                                    dataKey={player} 
                                                    stroke={`hsl(${idx * 360 / players.length}, 70%, 50%)`} 
                                                    strokeWidth={3} 
                                                    connectNulls 
                                                    dot={true}
                                                />
                                            ))}
                                        </LineChart>
                                    </ResponsiveContainer>
                                </div>

                                {players.map(player => {
                                    const runsRuts = getRunsAndRuts(player, currentData);
                                    if (runsRuts.length === 0) return null;
                                    
                                    return (
                                        <div key={player} className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                            <h2 className="text-xl font-bold mb-4">{player} - Runs & Ruts (15+ games)</h2>
                                            <div className="space-y-2">
                                                {runsRuts.map((period, idx) => (
                                                    <div 
                                                        key={idx} 
                                                        className={`p-3 rounded-lg ${period.type === 'run' ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'}`}
                                                    >
                                                        <div className="flex justify-between items-center flex-wrap gap-2">
                                                            <div>
                                                                <span className="font-semibold">Wordle {period.start} - {period.end}</span>
                                                                <span className="text-sm text-gray-600 ml-2">({period.length} games)</span>
                                                            </div>
                                                            <span className={`text-sm font-semibold ${period.type === 'run' ? 'text-green-700' : 'text-red-700'}`}>
                                                                {period.type === 'run' ? 'üî• RUN' : 'üò∞ RUT'} - Avg: {period.avg} ({period.diff > 0 ? '+' : ''}{period.diff})
                                                            </span>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    );
                                })}
                            </>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<WordleAnalyzer />, document.getElementById('root'));
    </script>
</body>
</html>
